/********************************************************************************
    File            : me2fs_super.c
    Description     : super block operations for my ext2 file sytem

********************************************************************************/
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/blkdev.h&gt;
#include &lt;linux/buffer_head.h&gt;

#include "me2fs.h"
#include "me2fs_util.h"


/*
=================================================================================

    Prototype Statement

=================================================================================
*/
static int me2fsFillSuperBlock( struct super_block *sb,
                                void *data,
                                int silent );

static void dbgPrintExt2SB( struct ext2_super_block *esb );
/*
=================================================================================

    DEFINES

=================================================================================
*/

/*
==================================================================================

    Management

==================================================================================
*/
/*
---------------------------------------------------------------------------------
    Super Block Operations
---------------------------------------------------------------------------------
*/
#if 0
static struct super_opearaions me2fs_super_ops =
{
};
#endif

/*
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    &lt; Open Functions &gt;

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/
/*
_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
    Function    :me2fsMountBlockDev
    Input       :struct file_system_type *fs_type
                 &lt; file system type &gt;
                 int flags
                 &lt; mount flags &gt;
                 const char *dev_name
                 &lt; device name &gt;
                 void *data
                 &lt; user data &gt;
    Output      :void
    Return      :struct dentry *
                 &lt; root dentry &gt;

    Description :mount me2fs over block device
_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
*/
struct dentry*
me2fsMountBlockDev( struct file_system_type *fs_type,
                    int flags,
                    const char *dev_name,
                    void *data )
{
    return( mount_bdev( fs_type, flags, dev_name, data, me2fsFillSuperBlock ) );
}

/*
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    &lt; Local Functions &gt;

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/
/*
==================================================================================
    Function    :me2fsFillSuperBlock
    Input       :struct super_block *sb
                 &lt; vfs super block object &gt;
                 void *data
                 &lt; user data &gt;
                 int silent
                 &lt; silent flag &gt;
    Output      :void
    Return      :void

    Description :fill my ext2 super block object
==================================================================================
*/
static int me2fsFillSuperBlock( struct super_block *sb,
                                void *data,
                                int silent )
{
    struct buffer_head      *bh;
    struct ext2_super_block *esb;
    int                     block_size;
    int                     ret = -EINVAL;
    unsigned long           sb_block = 1;

    /* ------------------------------------------------------------------------ */
    /* set device's block size to super block                                   */
    /* ------------------------------------------------------------------------ */
    block_size = sb_min_blocksize( sb, BLOCK_SIZE );

    DBGPRINT( "&lt;ME2FS&gt;Fill Super! block_size = %d\n", block_size );
    DBGPRINT( "&lt;ME2FS&gt;default block size is : %d\n", BLOCK_SIZE );

    if( !block_size )
    {
        DBGPRINT( "&lt;ME2FS&gt;error: unable to set blocksize\n" );
        return( ret );
    }

    if( !( bh = sb_bread( sb, 1 ) ) )
    {
        DBGPRINT( "&lt;ME2FS&gt;failed to bread super block\n" );
        return( ret );
    }

    esb = ( struct ext2_super_block* )( bh-&gt;b_data );

    dbgPrintExt2SB( esb );

    return( 0 );
}
/*
==================================================================================
    Function    :dbgPrintExt2SB
    Input       :struct ext2_super_block *esb
                 &lt; super block of ext2 file system &gt;
    Output      :void
    Return      :void

    Description :print ext2 super block
==================================================================================
*/
static void dbgPrintExt2SB( struct ext2_super_block *esb )
{
    unsigned int value;
    int i;
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_inodes_count ) );
    DBGPRINT( "&lt;ME2FS&gt;s_inode_count = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_blocks_count ) );
    DBGPRINT( "&lt;ME2FS&gt;s_blocks_count = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_r_blocks_count ) );
    DBGPRINT( "&lt;ME2FS&gt;s_r_blocks_count = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_free_blocks_count ) );
    DBGPRINT( "&lt;ME2FS&gt;s_free_blocks_count = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_free_inodes_count ) );
    DBGPRINT( "&lt;ME2FS&gt;s_free_inodes_count = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_first_data_block ) );
    DBGPRINT( "&lt;ME2FS&gt;s_first_data_block = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_log_block_size ) );
    DBGPRINT( "&lt;ME2FS&gt;s_log_block_size = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_log_frag_size ) );
    DBGPRINT( "&lt;ME2FS&gt;s_log_frag_size = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_blocks_per_group ) );
    DBGPRINT( "&lt;ME2FS&gt;s_blocks_per_group = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_frags_per_group ) );
    DBGPRINT( "&lt;ME2FS&gt;s_frags_per_group = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_inodes_per_group ) );
    DBGPRINT( "&lt;ME2FS&gt;s_inodes_per_group = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_mtime ) );
    DBGPRINT( "&lt;ME2FS&gt;s_mtime = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_wtime ) );
    DBGPRINT( "&lt;ME2FS&gt;s_wtime = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_mnt_count ) );
    DBGPRINT( "&lt;ME2FS&gt;s_mnt_count = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_max_mnt_count ) );
    DBGPRINT( "&lt;ME2FS&gt;s_max_mnt_count = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_magic ) );
    DBGPRINT( "&lt;ME2FS&gt;s_magic = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_state ) );
    DBGPRINT( "&lt;ME2FS&gt;s_state = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_errors ) );
    DBGPRINT( "&lt;ME2FS&gt;s_errors = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_minor_rev_level ) );
    DBGPRINT( "&lt;ME2FS&gt;s_minor_rev_level = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_lastcheck ) );
    DBGPRINT( "&lt;ME2FS&gt;s_lastcheck = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_creator_os ) );
    DBGPRINT( "&lt;ME2FS&gt;s_creator_os = %u\n", value );
    value = ( unsigned int )( le16_to_cpu( esb-&gt;s_rev_level ) );
    DBGPRINT( "&lt;ME2FS&gt;s_rev_level = %u\n", value );
    value = ( unsigned int )( le16_to_cpu( esb-&gt;s_def_resuid ) );
    DBGPRINT( "&lt;ME2FS&gt;s_def_resuid = %u\n", value );
    value = ( unsigned int )( le16_to_cpu( esb-&gt;s_def_resgid ) );
    DBGPRINT( "&lt;ME2FS&gt;s_def_resgid = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_first_ino ) );
    DBGPRINT( "&lt;ME2FS&gt;s_first_ino = %u\n", value );
    value = ( unsigned int )( le16_to_cpu( esb-&gt;s_inode_size ) );
    DBGPRINT( "&lt;ME2FS&gt;s_inode_size = %u\n", value );
    value = ( unsigned int )( le16_to_cpu( esb-&gt;s_block_group_nr ) );
    DBGPRINT( "&lt;ME2FS&gt;s_block_group_nr = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_feature_compat ) );
    DBGPRINT( "&lt;ME2FS&gt;s_feature_compat = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_feature_incompat ) );
    DBGPRINT( "&lt;ME2FS&gt;s_feature_incompat = %u\n", value );
    DBGPRINT( "&lt;ME2FS&gt;s_uuid[ 16 ] = " );
    for( i = 0 ; i &lt; 16 ; i++ )
    {
        DBGPRINT( "%02X", esb-&gt;s_uuid[ i ] );
    }
    DBGPRINT( "\n" );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_journal_inum ) );
    DBGPRINT( "&lt;ME2FS&gt;s_journal_inum = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_journal_dev ) );
    DBGPRINT( "&lt;ME2FS&gt;s_journal_dev = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_last_orphan ) );
    DBGPRINT( "&lt;ME2FS&gt;s_last_orphan = %u\n", value );
    DBGPRINT( "&lt;ME2FS&gt;s_hash_seed[ 4 ] = " );
    for( i = 0 ; i &lt; 4 ; i++ )
    {
        DBGPRINT( "%16X", esb-&gt;s_hash_seed[ i ] );
    }
    DBGPRINT( "\n" );
    value = ( unsigned int )( esb-&gt;s_def_hash_version );
    DBGPRINT( "&lt;ME2FS&gt;s_def_hash_version = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_default_mount_opts ) );
    DBGPRINT( "&lt;ME2FS&gt;s_default_mount_opts = %u\n", value );
    value = ( unsigned int )( le32_to_cpu( esb-&gt;s_first_meta_bg ) );
    DBGPRINT( "&lt;ME2FS&gt;s_first_meta_bg = %u\n", value );
}
/*
==================================================================================
    Function    :void
    Input       :void
    Output      :void
    Return      :void

    Description :void
==================================================================================
*/

